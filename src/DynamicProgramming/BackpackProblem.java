package DynamicProgramming;


/**
 * @author 黄子玉
 * 时间：2019/07/06 10:00
 * 经典背包问题：假设有a，b，c，d，e五件宝物（不是五种），它们的重量分别是2,2,6,5,4，它们的价值是6,3,5,4,6，
 * 现在给个承重10的背包，怎么装才能使得价值最大？
 * 分析：首先画出一张表格(e2表示e行2列，单元格的意义是只有e物品时，有个承重为2的背包，背包的最大价值为0.)
 * (d2单元格表示只有物品d、e时，有个承重为2的背包，背包的最大价值为0.)(表格明显是从下至上，从左至右填写出来的.)
 * name weight value  1  2  3  4  5  6  7  8  9  10
 *  a     2      6    0  6  6  9  9  12 12 15 15 15
 *  b     2      3    0  3  3  6  6  9  9  9  10 11
 *  c     6      5    0  0  0  6  6  6  6  6  10 11
 *  d     5      4    0  0  0  6  6  6  6  6  10 10
 *  e     4      6    0  0  0  6  6  6  6  6  6  6
 *  如果从上往下排那就是：
 *  name weight value  1  2  3  4  5  6  7  8  9  10
 *  a     2      6     0  6	 6	6  6  6	 6	6  6  6
 *  b     2      3     0  6	 6	9  9  9	 9	9  9  9
 *  c     6      5     0  6	 6	9  9  9	 9	11 11 14
 *  d     5      4     0  6	 6	9  9  9	 10	11 13 14	
 *  e     4      6     0  6	 6	9  9  12 12	15 15 15
 *  结果还是一样的。	
 *  
 *  背包问题的状态转移方程f[i,j]=max{f[i-1,j-w(i)]+p(i)(j>=w(i)),f[i-1,j]]}
 *  f[i,j]表示在前i件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值。
 *  p(i)表示第i件物品的价值。
 *  结合上面的问题，我们分析a8=15.
 *  首先看f[i-1,j]对应这里的就是b8，值为9.还有个值是f[i-1,j-w(i)]+p(i).对应这里：
 *  f[i-1,j-w(i)]我有个承重为6的包，当只有物品b,c,d,e四件可以选择时，背包能够装入的最大价值。对应b6，值为9
 *  f[i-1,j-w(i)]+p(i)=9+6=15.所以最大为15.
 */



/**
 * @author 黄子玉
 * 这是最经典的0-1背包问题，即每种物品只有一个，可以选择放或者不放入背包。
 * 还有延伸出来的两个背包问题，分别是完全背包和多重背包。
 * 首先介绍完全背包问题，完全背包问题加了个条件就是每种物品有无限个，类推转移方程是：
 * f[i,j]=max{f[i-1,j-k*w(i)]+k*p(i)(j>=k*w(i)),f[i-1,j]]}
 *再来介绍下多重背包的问题，多重背包是在完全背包的基础上规定了每件物品有n(i)个，类推转移方程：
 *f[i,j]=max{f[i-1,j-k*w(i)]+k*p(i)(j>=k*w(i)&&k<=n(i)),f[i-1,j]]}
 */
public class BackpackProblem {
	/**
	 * @param m 背包容量
	 * @param n 商品个数
	 * @param w 商品重量数组
	 * @param p 商品价值数组
	 *
	 */
	public static int[][] backpack_Solution(int m,int n,int[] w,int[] p){
		//c[i][v]表示前i件物品恰放入一个重量为m的背包可以获得的最大价值
		int c[][]=new int[n+1][m+1];
		for(int i=0;i<=n;i++){
			c[i][0]=0;//背包容量为0价值肯定为0
		}
		for(int j=0;j<=m;j++){
			c[0][j]=0;//0件物品可选，价值肯定也为0
		}
		
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				//当物品为i件重量为j时，如果第i件的重量(w[i-1])小于重量j时，c[i][j]为下列两种情况之一：
                //(1)物品i不放入背包中，所以c[i][j]为c[i-1][j]的值
                //(2)物品i放入背包中，则背包剩余重量为j-w[i-1]
				//所以c[i][j]为c[i-1][j-w[i-1]]的值加上当前物品i的价值
				if(w[i-1]<=j){
					if(c[i-1][j]<(c[i-1][j-w[i-1]]+p[i-1]))
						c[i][j]=c[i-1][j-w[i-1]]+p[i-1];
					else
						c[i][j]=c[i-1][j];
				}else{
					c[i][j]=c[i-1][j];
				}
			}
		}
		return c;
	}
	//验证方法的正确性
	public static void main(String[] args) {
		int m=10;
		int n=5;
		int p[]={6,3,5,4,6};
		int w[]={2,2,6,5,4};
		int c[][]=BackpackProblem.backpack_Solution(m,n,w,p);
		for (int i = 1; i <=n; i++) {
            for (int j = 1; j <=m; j++) {
                System.out.print(c[i][j]+"\t");
                if(j==m){
                    System.out.println();
                }
            }
        }
	}

}
